<!-- .slide: data-auto-animate -->

### Performance

For every mutation we run the whole test suite once.
<!-- .element: class="fragment semi-fade-out" data-fragment-index="1" -->

![time complexity](img/timecomplexity.png)
<!-- .element class="fragment semi-fade-out" data-fragment-index="1" -->

We need to be smarter: ![do faster](img/faster.png)
<!-- .element class="fragment" data-fragment-index="1" -->


<!-- .element class="fragment" data-fragment-index="1" -->

---

<!-- .slide: data-auto-animate -->

### Performance

Three approaches to improving performance

* 🏎️ Do **faster**<span class="fragment" data-fragment-index="1">: 27 studies</span>
* 🦥 Do **fewer**<span class="fragment" data-fragment-index="1">: 118 studies</span>
* 🧐 Do **smarter**<span class="fragment" data-fragment-index="1">: 75 studies</span>

A. Pizzoleto, F. Ferrari, J. Offutt, L. Fernandes, and M. Ribeiro, “A systematic literature
review of techniques and metrics to reduce the cost of mutation testing,” Journal of Systems
and Software, vol. 157, Jul. 2019. DOI: 10.1016/j.jss.2019.07.100.

<!-- .element class="attribution" -->

---

### Common techniques

<div class="r-hstack items-equal items-start items-gap">

<div>

- 🦥 Random mutation
- 🧐 Evolutionary algorithms
- 🦥 Data-flow analysis
- 🧐 Model-based mutation
- 🧐 State-based analysis
- 🦥 Incremental mutation testing
- 🦥 Minimal mutation

</div>
<div>

- 🦥 Constrained mutation
- 🏎️ Parallel execution
- 🦥 Control-flow analysis
- 🧐 Minimization and prioritization of test sets
- 🦥 Smart bail / fast fail
- 🧐 Higher order mutation
- 🦥 Selective mutation

</div>
</div>

Note:
#### 🦥 Random mutation

> This technique selects randomly from the complete set of mutants according to a predefined probability distribution.
> Random mutation has been interpreted as "choose X% of all mutants," "for each mutant, generate it with X% probability," and as "choose X% of mutants generated by each operator".

#### 🦥 Data-flow analysis

> This technique uses program data-flow-related information to decide which mutants to generate and to analyze mutants.
> It considers whether variables that are more prone to failure during execution are reached and referenced.


#### 🧐 Evolutionary algorithms

> This technique uses evolutionary algorithms to reduce the number of mutants, to reduce the number of test cases, or to identify equivalent mutants.

#### 🧐 Model-based mutation

> This technique mutates formal or informal models of the program, and then uses the mutants to automatically generate test cases that are later used to kill mutants of the program.

#### 🧐 State-based analysis

> This technique compares states of different mutant executions.
> When two mutants lead to the same mutation state, that is, when the same execution path is observed, only one needs to be executed and the result of the other can be inferred.
> Similarly, the technique creates groups of classes that deffne certain transition sequences such that only one needs to be verified.

#### 🦥 Minimal mutation

> This technique identifies and eliminates redundant mutants by applying the concepts of mutant subsumption and dominator mutants.



