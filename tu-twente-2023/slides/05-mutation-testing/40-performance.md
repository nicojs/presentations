## Improving Performance

> T<sub>total</sub> <span class="fragment" data-fragment-index="0">!</span>= T<sub>test</sub> * N

<!-- .element class="text-xl" -->

<emoji-list>

* â© Do faster
* ğŸ”½ Do fewer
* ğŸ§ Do smarter

</emoji-list>

<!-- .element class="fragment" data-fragment-index="1" -->

A. Pizzoleto, F. Ferrari, J. Offutt, L. Fernandes, and M. Ribeiro, â€œA systematic literature
review of techniques and metrics to reduce the cost of mutation testing,â€ Journal of Systems
and Software, vol. 157, Jul. 2019. DOI: 10.1016/j.jss.2019.07.100 (cit. on pp. 15, 18).

<!-- .element class="citation fragment" data-fragment-index="1" -->

----

### Cost reduction timeline

![](/img/cost-reduction-time-line.PNG)

--- 

### Random mutation:

> This technique selects randomly from the complete set of mutants according to a predefined probability distribution. Random mutation has been interpreted as "choose X% of all mutants," "for each mutant, generate it with X% probability," and as "choose X% of mutants generated by each operator".

---

### Higher order mutation:

> This technique combines two or more simple mutations to create a single complex mutant.


---

### Parallel execution:

> This technique executes mutants in parallel processors, reducing
the total time needed to perform mutation analysis.

---

### Data-flow analysis:

> This technique uses program data 
ow-related information to decide
which mutants to generate and to analyze mutants. It considers whether variables
that are more prone to failure during execution are reached and referenced.

--- 

### Control-flow analysis:

> This technique uses program control 
ow-related information,
focusing on execution characteristics to identify branches and commands that help determine
which structures are most relevant to the generation and execution of mutants.


--- 

### Minimization and prioritization of test sets:

> This technique analyzes the test suite to
score test cases based on their effectiveness at killing mutants, then either eliminates
test cases that are ineffective or runs the most effective test cases before the less effective
test cases.

---

### Constrained mutation:

> This technique chooses a subset of mutation operators to use.
The choice relies on testers' intuition regarding the signiffcance of particular groups of
mutants.

---

### Evolutionary algorithms:

> This technique uses evolutionary algorithms to reduce the
number of mutants, to reduce the number of test cases, or to identify equivalent mutants.

---

### Model-based mutation:

> This technique mutates formal or informal models of the program,
and then uses the mutants to automatically generate test cases that are later
used to kill mutants of the program.

---

### State-based analysis:

> This technique compares states of different mutant executions.
When two mutants lead to the same mutation state, that is, when the same execution
path is observed, only one needs to be executed and the result of the other can be
inferred. Similarly, the technique creates groups of classes that deffne certain transition
sequences such that only one needs to be verified.

---

### Minimal mutation:

> This technique identiffes and eliminates redundant mutants by
applying the concepts of mutant subsumption and dominator mutants.

---

### Selective mutation:

> This technique tries to avoid the application of mutation operators
that are responsible for the most mutants or to select mutation operators that result in
mutants that are killed by tests that also kill lots of mutants created by other operators.
The idea is that if a test set, T<sub>op</sub>, that is adequate for a subset of mutation operators <sub>op</sub>,
also kills a very high percentage of all mutants, then we can select only the operators.
in op.
